项目的架构：三层架构
    表现层(web层，视图层，表示层...) : （用户能够直接访问的内容）Servlst、html...
    业务逻辑层(Service层) : java类，提供处理业务的方法
    数据持久化层： DAO层(和数据库交互)
                只操作数据库，提供对数据库数据的CURD
                项目中的DAO层因为需求经常发生变化,DAO层通常面向接口编程，使用接口规范对表的操作
     数据库



开发流程：
    1.数据库表【bookstore,bs_user】
    2.对应一张表创建一个javabean【user】
    3.导入数据库相关的jar包【mysqlconnection数据库驱动,c3p0数据库连接池jar包和相关配置文件,DBUtils工具类】
    4.修改c3p0配置文件的数据：数据库名、账号密码
    5.JDBUtils工具类【获取数据库连接和释放连接的方法】
    6.baseDAO提供对数据库的基本操作，包括【CURD，查询一条记录，查询一个集合】
    7.UserDAO提供对bs_user表的所有操作
            UserDAO 接口
            UserDAOImpl 具体表操作的实现
    8.完成注册功能注册
        注册页面(regist.html)-->提交注册需求-->RegistServlst(收集用户的注册请求，调用UserDAO插入到数据库中)
        -->如果插入成功-->重定向到注册注册成功页面(regist_success.html)
        RegistServlet:
            修改form表单的action的提交地址
            修改页面中引入的css和jQuery文件的路径
    9.完成登录功能
        登录页面(login.html)-->提交登录请求-->LoginServlet(收集用户的登录请求，调用UserDAO从数据库中获取用户)
        -->如果查询对象不为null-->登录成功-->重定向到登录成功的页面(login_success.html)
        -->如果为null-->登录失败-->转发到登录页面让用户继续登录(longin.html)
        LoginServlet：
》》 第三阶段 项目优化
   》》将html页面转换为jsp
   》》提取页面相同内容，通过 include 静态引入 base link script
   》》用户登录失败和注册失败，转发到登录或注册页面时，没有错误提示
   》》用户注册失败时，转发到注册页面时，可以将用户的输入信息进行 回显
   》》将一类的操作封装到一个servlet中，整合 servlet 到 userserlvet
   》》我们经常获取的参数封装为一个对象，如果参数过多、获取代码过多，提供一个工具类方法专门用来封装对象
   1.拷贝一个新的项目 bookstore——03
        修改工程名
        修改-首选项-web工程设置-修改 content root的值
   2.修改html页面为jsp页面
    》现在html页面添加jsp首行
    》再修改文件的后缀名.jsp
   3.提取页面中相同的内容，通过include引入
      》提取base标签：link jquery
        -每个页面引入base.jsp
      》提取页面用户访问的头部
        -在用户使用的页面中引入base.jsp
      》提取管理员用户的导航栏
        -在管理员用户页面中引入 manager_navigate.jsp
    4.修改提交页面中的页面后缀和路径<和base引入标签拼接>
    5.修改servlet中的重定向和转发文件后缀名
    6.动态获取base标签的url地址《base.jsp中的base标签》
    7.登录失败时，在转发的login.jsp页面给出错误tip
        用户在login.jsp页面输入账号密码
        提交给loginServlet，判断【if login fail，setAttr a errorMsg in request area 】
        如果失败 ，转发到login.jsp页面【getAttr a errorMsg in request area】
        此时显示登录失败
    8.注册失败时，在转发的regist.jsp显示错误tip
        用户在regist.jsp页面注册账号时
        提交给registServlet，判断【if regist fail，setAttr a errorMsg in request area】
        如果失败，转发到regist.jsp页面【this user is exist】
        此时显示注册失败
    9.模拟service对servlet进行整合
        一个功能对应一个方法
        在login.jsp页面的表单中添加一个参数，告诉servlet 的 请求方式
        参数name的属性值一样method，value值不同
        》提供一个userServlet处理所有的和用户有关的请求【登录 and 注册】
            提供登录和注册的方法，在servlet中判断请求参数的method的value 进而调用不同的方法
    10.使用反射，根据请求参数中的method的值来自动调用方法
        》创建一个baseServlet对httpServlet进一步封装，项目中的其他servlet都继承baseServlet
            在base中获得请求参数method的值，自动调用子类的方法
            只有baseServlet有doGet 和 doPost 方法
            所有的baseServlet的子类不能有doGet 和 doPost方法
    11.提供一个工具类测试方法 自动读取参数并封装为对象
        使用BeanUtils.jar包
项目第四阶段：
        在项目中使用EL和JSTL
    1.使用EL表达式替换jsp
        login.jsp
        regist.jsp
        base.jsp    base标签中 拼接url地址
        include 文件夹中所有的内容不希望用户能直接访问
    2.使用jstl+el 完成图书的增删改查
开发流程》》》从数据源--DAO--service--servlet【遍历调试】
        》创建bs_book
            int id,String title,String author,double price,int sales,int stock,String imgPath
        》对应表创建 javaBean Book
        》创建BookDao 和 BookDaoImpl
              Book  getBookById(String id)
              List<Book>  getBookList()
              int  saveBook(Book book)
              int  updateBook(Book newBook)
              int  delBook(String id)
         》创建BookService 和 BookServiceImpl
         》创建BookMangerServlet 继承BaseServlet
            getBookList() 查询所有图书
                点击后台管理-图书管理超链接时获取图书的列表并展示
                点击图书管理-请求交给BookMangerServlet的getBookList()方法处理再转发到bookManger.jsp展示
                修改图书管理的超链接<a href='manger/BookMangerServlet?method=getBookList'>图书管理</a>
            deleteBook() 删除指定的图书
                在book_manger.jsp页面点击删除的超链接[含有id]
                请求提交给BookMangerServlet的deleteBook()方法,修改<a href='manger/BookMangerServlet?method=getBookList'>删除</a>
                删除之后：需要重定向到getBookList方法中重新查询图书集合
                》点击删除时，提示友好提示框 confirm()
            addBook() 添加图书
                在book_manger.jsp页面点击添加图书跳转到book_add.jsp页面
                book_add.jsp中的from表单提交给BookMangerServlet的addBook()方法处理<from action="manger/BookMangerServlet" method="post">
                book_add.jsp 表单项的name属性值与book类属性名一致
            乱码问题：
                数据存到数据库时有乱码：post请求乱码
                解决：在BaseServlet中的doget()方法中第一行设置编码格式 request.setCharacterEndcoding("utf-8");
            getBook() 根据id查到需要修改的图书
                book_manger.jsp页面点击修改按钮提交给getBook方法处理：<a href="manger/BookMangerServlet?method=getBook">修改</a>
            editBook() 修改图书
                注意：book_edit.jsp页面需要使用隐藏域携带id和img参数
                book_edit.jsp页面点击提交时交给editBook()方法处理：<from action="manger/BookMangerServlet">
            》以后开发中不推荐使用不带条件的sql语句
                不带条件的sql语句查询效率低，影响用户体验
                SELECT * 不要使用
                一页数据过多，使用分页展示
                技术基础：SELECT * FROM bs_book limit index,size
                       例如： SELECT * FROM bs_book limit 5,0 从第0条到第5条数据
            》创建Page类
                List<T> data;
                int pageNumber;
                int totalPage;
                int totalCount;
                int size;
                int index;
            》分页访问流程
                用户访问 携带pageNumber --》BookManagerServlet【findPage()获取pageNumber，设置size】
                        --》调用BookService处理分页的业务逻辑【getPage()：创建一个page类，将size和pageNumber设置给page对象，index可以计算得到】
                        --》调用BookDao查询分页数据【getPageBook(Page page)：根据page对象的size和index查询data，查询图书总数量totalCount，totalPage可以计算得到】
                            page对象的所有属性都初始化成功，return
                开发流程：倒序开发
                        BookDao：Page<Book> getPageBook(Page<Book> page) ;
                            查询和数据库相关的数据[查询图书记录总条数，查询分页显示的图书集合]
                            》》在BaseDao中提供一个查询记录总条数的方法
                                getCount()
                            》》查询图书总条数：totalCount，page.setTotalCount(totalCount)
                            》》查询分页图书集合：booklist = getBeanList() --》 page.setData(booklist)
                        BookService：
                            创建Page对象，将size和pageNumber设置给对象
                                getPage()
                            》》创建Page()对象
                            》》pageNumber：转换为int类型设置给page对象
                            》》size：设置给page对象
                        BookManagerServlet:
                            findPage()：处理用户的分页请求
                                      》》获取pageNumber，设置size
                                      》》调用service处理业务得到page对象
                                      》》将page设置到域中
                                      》》转发到book_manager.jsp页面展示分页数据
                        》》修改manager.jsp页面中图书管理的超链接，点击时访问BookManagerServlet?method=findPage查询分页数据
                        》修改manager.jsp页面中图书管理超链接，点击时访问BookMangerServlet.findPage查询分页数据
                        》修改book_manager.jsp页面获取域中数据显示的方式
                        》在page类的getPageNumber中可以显示pageNumber的范围
                        》分页导航栏
                            如果页码过多，页码显示太乱
                            控制一次显示5个页码
                                【1】  2   3   4   5
                                  1  【2】 3   4   5
                                  1   2  【3】 4   5
                                  2   3  【4】 5   6

                                                                    begin       end
                                          总页码《=5                   1            totalPage
                                        总页码》5
                                          pageNumber《3               1            5
                                          pageNumber》=3             pageNumber-2 pageNumber+2
                                            end》=totalPage          totalPage-4  totalPage
                                            end《totalPage